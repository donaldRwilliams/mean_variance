---
  output: github_document
---
  <!-- README.md is generated from README.Rmd. Please edit that file -->
```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/README-",
  dev = "png",
  dpi = 500,
  fig.asp = 0.8,
  fig.width = 7,
  out.width = "60%",
  fig.align = "center"
)
```
This document reproduces the analyses, plots, model comparisons, etc. included in the paper. The following is in order of appearance.

# The Mixed-Effects Location Scale Model
## Random Intercepts Only Model

A random intercepts model was first fitted to both the location and scale. For the $i$th person and $j$th trial in the congruent condition, the mean structure is defined as

\begin{align}
\label{eq:int_only_mu}
y_{ij} = \beta_0 + u_{0i} + \epsilon_{ij},
\end{align}


where $\beta_0$ is the fixed effect and $u_{0i}$ the individual deviation. More specifically, $\beta_0$ is the average of the individual means and for, say, the first subject ($i = 1$), the respective mean response time is $\beta_0 + u_{01}$. This is not equivalent to estimating the empirical means, because of the hierarchical structure of the model. Before describing this aspect of the model, we must account for the ``errors''. While they are typically assumed to be normally distributed with a constant variance, this is not the case for the MELSM--i.e., 

\begin{equation}
\sigma^2_{\epsilon_{ij}}  = \text{exp}[\eta_0 + u_{1i}].
\end{equation}


Load the following packages and data:
  ```{r echo=T, message=F, warning=F}
library(brms)
library(dplyr)
library(ggplot2)
library(cowplot)
library(reshape)
library(devtools)
library(rethinking)

# read the data
ur <- "https://raw.githubusercontent.com/PerceptionCognitionLab/data0/master/contexteffects/FlankerStroopSimon/cleaning.R"
source_url(ur)

```
You can estimate the following models, or assuming the entire working directory was downloaded, you can skip ahead and load the fitted objects. Note that two are mixed effects models, and are used for model comparison.
```{r,  eval = F, echo=T, message=F, warning=F}
# melsm: mixed effects location scale model
# me: mixed effects model
fit_1 <- brm(bf(rt ~ 1 + (1|c|ID), sigma ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "incongruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

# remove scale model
fit_2 <- brm(bf(rt ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "incongruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

# congruent intercept only
fit_3 <- brm(bf(rt ~ 1 + (1|c|ID), sigma ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "congruent"),
             inits = 0, cores = 2, chains = 2, iter = 2000, 
             warmup = 1000)


# check to easy worry of ``over-fitting''
# remove scale model
fit_4 <- brm(bf(rt ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "congruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

```

Load the fitted models, and then compare with WAIC.
```{r warning=F}
load("fit_1.RData")
load("fit_2.Rdata")
load("fit_3.Rdata")
load("fit_4.Rdata")

# incong_waic <- WAIC(fit_1, fit_2)
# cong_waic <- WAIC(fit_3, fit_4)

# incongruent model comparison
# incong_waic$ic_diffs__

# congruent model comparison
# cong_waic$ic_diffs__
```

Make plot 1 from the fitted objects. First for the incongruent model. Figure 1 (bottom):
```{r message = F}
# use "Times" font
windowsFonts(Times = windowsFont("Times New Roman"))

re_mean_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("r_ID")) %>% 
  select(-contains("sigma"))

fe_mean_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("b_Intercept")) 

re_mean_in <- (re_mean_in + fe_mean_in[,1]) 
colnames(re_mean_in) <- 1:121

# empirical estimates
emp_est_in <- stroop %>% 
  filter(congruency == "incongruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1A <- melt(re_mean_in) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_mu = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(mu_emp = emp_est_in$mean_emp) %>%
  arrange(mu_mu) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "mean", 
         outcome = "Incongruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(posterior_summary(fit_1, "b_")[1,1],2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_mu), 
             size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = mu_emp), 
             size = 2, 
             color = "#D55E00",
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Mean") +
  xlab("Ascending Index") +
  ggtitle("Incongruent Responses") +
  scale_y_continuous(breaks = c(0.6, 0.7, 0.77, 0.9, 1))

plot_1A
```


Plot 1B:
```{r warning = F, message = F}
# extract posterior estimates
re_sigma_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("r_ID__sigma")) 

fe_sigma_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("b_sigma_Intercept")) 

re_sigma_in <- exp(re_sigma_in + fe_sigma_in[,1]) 
colnames(re_sigma_in) <- 1:121

# randomly sample 60 eople
set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

# plot 1a
plot_1B <- melt(re_sigma_in) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_sigma = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(sd_emp = emp_est_in$sd_emp) %>%
  arrange(mu_sigma) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "SD", 
         outcome = "Incongruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(exp(posterior_summary(fit_1, "b_")[2,1]),2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_sigma), size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = sd_emp), 
             size = 2, 
             color = "#D55E00", 
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 16)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Standard Deviation") +
  xlab("Ascending Index") +
  ggtitle("")

plot_1B
```


The following has the empirical and model based estimates in the same plot. Plot 1C:
```{r }
dat_model_in <- data.frame(type = "Hierarchical",  
                           mean = colMeans(re_mean_in), 
                           sd = colMeans(re_sigma_in))


dat_data_in <- data.frame(type = "Empirical",  
                          mean = emp_est_in$mean_emp, 
                          sd = emp_est_in$sd_emp)


dat_plt_in <- rbind.data.frame(dat_model_in, dat_data_in)
dat_plt_in$ID <- 1:121

plot_1C <- ggplot(dat_plt_in, aes(y = sd, 
                                  x = mean, 
                                  color = type)) +
  geom_line(aes( group = ID), 
            color =  "black", 
            alpha = 0.25, 
            size = 1) +
  geom_point(size = 2, alpha = 0.75) +
  geom_smooth(method = "lm", se = F, show.legend = F) +
  scale_color_manual(values =c( "#0072B2", "#D55E00")) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14),
        legend.text = element_text(size = 13),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        legend.title = element_blank(), 
        legend.background = element_rect(color = "black"),
        legend.margin=margin(c(1,1,1,1))) +
  xlab("Mean") +
  ylab("Standard Deviation") +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("") 

plot_incong <- plot_grid(plot_1A, plot_1B, plot_1C, nrow = 1)

# ggsave(plot = plot_incong, filename = "plot_1.pdf", width = 8, height = 5)
```

Continue making plot 1 from the fitted objects. Now for the congruent model. Figure 1 (top):
```{r message=F}
re_mean_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("r_ID")) %>% 
  select(-contains("sigma"))

fe_mean_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("b_Intercept")) 

re_mean_con <- (re_mean_con + fe_mean_con[,1]) 
colnames(re_mean_con) <- 1:121

# empirical estimates
emp_est_con <- stroop %>% 
  filter(congruency == "congruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)


set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1D <- melt(re_mean_con) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_mu = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(mu_emp = emp_est_con$mean_emp) %>%
  arrange(mu_mu) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "mean", 
         outcome = "Congruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(posterior_summary(fit_3, "b_")[1,1],2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_mu), 
             size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  
  # empirical estimates
  geom_point(aes(x = index, 
                 y = mu_emp), 
             size = 2, 
             color = "#D55E00",
             alpha = 0.75) +
  
  # times font
  theme_bw(base_family = "Times") +
  
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Mean") +
  xlab("Ascending Index") +
  ggtitle("Congruent Responses") +
  scale_y_continuous(breaks = c(0.6, 0.71, 0.8, 0.9, 1))

plot_1D
```


```{r message=F}
re_sigma_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("r_ID__sigma")) 

fe_sigma_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("b_sigma_Intercept")) 

re_sigma_con <- exp(re_sigma_con + fe_sigma_con[,1]) 
colnames(re_sigma_con) <- 1:121

# empirical estimates
emp_est_con <- stroop %>% 
  filter(congruency == "congruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1E <- melt(re_sigma_con) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_sigma = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(sd_emp = emp_est_con$sd_emp) %>%
  arrange(mu_sigma) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "SD", 
         outcome = "Congruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(exp(posterior_summary(fit_3, "b_")[2,1]),2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up),width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_sigma), size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = sd_emp), 
             size = 2, 
             color = "#D55E00", 
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Standard Deviation") +
  xlab("Ascending Index") +
  ggtitle("") +
  scale_y_continuous(breaks = c(0.1, 0.17, 0.3))

plot_1E
```


Model based and emprical plot:
```{r}
dat_model_con <- data.frame(type = "Hierarchical",  
                            mean = colMeans(re_mean_con), 
                            sd = colMeans(re_sigma_con))


dat_data_con <- data.frame(type = "Empirical",  
                           mean = emp_est_con$mean_emp, 
                           sd = emp_est_con$sd_emp)


dat_plt_con <- rbind.data.frame(dat_model_con, dat_data_con)
dat_plt_con$ID <- 1:121

plot_1F <- ggplot(dat_plt_con, aes(y = sd, 
                                   x = mean, 
                                   color = type)) +
  geom_line(aes( group = ID), 
            color =  "black", 
            alpha = 0.25, 
            size = 1) +
  # points
  geom_point(size = 2, 
             alpha = 0.75) +
  # add fitted line
  geom_smooth(method = "lm", 
              se = F, 
              show.legend = F) +
  # color blind pallette
  scale_color_manual(values =c( "#0072B2", "#D55E00"), 
                     name = "") +
  # fav theme with times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 16),
        legend.position = "none") +
  xlab("Mean") +
  ylab("Standard Deviation") +
  # remove transparency from legend points
  guides(colour = guide_legend(override.aes = list(alpha=1))) +
  ggtitle("") 


plot_cong <- plot_grid(plot_1D, plot_1E, plot_1F, nrow = 1)
plot_1 <- plot_grid(plot_cong, plot_incong, nrow = 2)

plot_1
# ggsave(filename = "plot_1.pdf", plot = plot_1, width = 9.5, height = 6.5)
```


We also breifly compared the correlation between the model based and emprical means and standard deviations. For the incongruent responses:
```{r}
# correlate incongruent M's and SD's

# emprical
emp_cor_in <- cor(dat_data_in[,2:3])[1,2]
boot_in <- replicate(1000, cor(dat_data_in[sample(1:121, 121, replace = T),2:3])[1,2])
emp_cor_sd_in <- sd(boot_in)

# model
model_cor_in <- mean(posterior_samples(fit_1, pars = "cor")[,1])
model_cor_sd_in <- sd(posterior_samples(fit_1, pars = "cor")[,1])

data.frame(type = c("emprical", "model"), 
           cor = c(emp_cor_in, model_cor_in),
           cor_sd = c(emp_cor_sd_in, model_cor_sd_in))
```

Now for the congruent responses:
```{r}
# correlate congruent M's and SD's

# emprical
emp_cor_con <- cor(dat_data_con[,2:3])[1,2]
boot_con <- replicate(1000, cor(dat_data_con[sample(1:121, 121, replace = T),2:3])[1,2])
emp_cor_sd_con <- sd(boot_con)

# model
model_cor_con <- mean(posterior_samples(fit_3, pars = "cor")[,1])
model_cor_sd_con <- sd(posterior_samples(fit_3, pars = "cor")[,1])

data.frame(type = c("emprical", "model"), 
           cor = c(emp_cor_con, model_cor_con),
           cor_sd = c(emp_cor_sd_con, model_cor_sd_con))
```

Thus far the work showed how the mixed-effects location scale model can estimate mean-variance relations. This lead naturally to testing the correlations. The following visualizes the LKJ prior distribution for the partial correlations:
```{r}
##############################
#### lkj marginals ###########
##############################
# nu 1
nu_1 <- rethinking::rlkjcorr(1000000, 
                             K = 4, 
                             eta = 1)[,,1][,2]
# nu 2
nu_2  <- rethinking::rlkjcorr(1000000, 
                              K = 4, 
                              eta = 2)[,,1][,2]
# nu 3
nu_3  <- rethinking::rlkjcorr(1000000, 
                              K = 4, 
                              eta = 3)[,,1][,2]
# nu 4
nu_4  <- rethinking::rlkjcorr(1000000, 
                              K = 4, 
                              eta = 4)[,,1][,2]

# data for plotting
lkj_dat <- data.frame(nu = as.factor(rep(1:4, each = 10000)), 
                      sample = c(nu_1[1:10000], 
                                 nu_2[1:10000],
                                 nu_3[1:10000], 
                                 nu_4[1:10000]))

lkj_dat %>% 
  ggplot() +
  # for linetype
  geom_line(stat = "density", 
            aes(linetype = nu, x = sample), 
            adjust = 1.5) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        # top right legend
        legend.justification=c(1,1), 
        legend.position=c(1,1),
        legend.background = element_rect(color = "black")) +
  xlab( expression("Marginal Prior Distribution"~ italic(rho[i][j]))) +
  ylab("Density") +
  scale_linetype_manual(name = expression("  "~italic(nu)), 
                        values = c("solid", "longdash", "dotted", "dotdash"))

```

