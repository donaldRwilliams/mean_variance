---
  output: github_document
---
  <!-- README.md is generated from README.Rmd. Please edit that file -->
```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/README-",
  dev = "png",
  dpi = 500,
  fig.asp = 0.8,
  fig.width = 7,
  out.width = "80%",
  fig.align = "center"
)
```
# Beneath the Surface: Unearthing Within-Person Variability and Mean Relations with Bayesian Mixed Models

This document reproduces the analyses, plots, model comparisons, etc. included in the paper. The following is in order of appearance.

## The Mixed-Effects Location Scale Model
### Random Intercepts Only Model

A random intercepts model was first fitted to both the location and scale. For the $i$th person and $j$th trial in the congruent condition, the mean structure is defined as

$$
y_{ij} = \beta_0 + u_{0i} + \epsilon_{ij},
$$


where $\beta_0$ is the fixed effect and $u_{0i}$ the individual deviation. More specifically, $\beta_0$ is the average of the individual means and for, say, the first subject ($i = 1$), the respective mean response time is $\beta_0 + u_{01}$. This is not equivalent to estimating the empirical means, because of the hierarchical structure of the model. Before describing this aspect of the model, we must account for the ``errors''. While they are typically assumed to be normally distributed with a constant variance, this is not the case for the MELSM--i.e., 

$$
\sigma^2_{\epsilon_{ij}}  = \text{exp}[\eta_0 + u_{1i}].
$$


Load the following packages and data:
```{r echo=T, message=F, warning=F}
library(brms)
library(dplyr)
library(ggplot2)
library(cowplot)
library(reshape)
library(devtools)
library(rethinking)

# read the data
ur <- "https://raw.githubusercontent.com/PerceptionCognitionLab/data0/master/contexteffects/FlankerStroopSimon/cleaning.R"
source_url(ur)

```
Estimate the following models. Note that two are mixed effects models, and are used for model comparison.
```{r,  eval = F, echo=T, message=F, warning=F}
# melsm: mixed effects location scale model
# me: mixed effects model
fit_1 <- brm(bf(rt ~ 1 + (1|c|ID), sigma ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "incongruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

# remove scale model
fit_2 <- brm(bf(rt ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "incongruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

# congruent intercept only
fit_3 <- brm(bf(rt ~ 1 + (1|c|ID), sigma ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "congruent"),
             inits = 0, cores = 2, chains = 2, iter = 2000, 
             warmup = 1000)


# check to easy worry of ``over-fitting''
# remove scale model
fit_4 <- brm(bf(rt ~ 1 + (1|c|ID)), 
             data = stroop %>% filter(congruency == "congruent"),
             inits = 0, cores = 2, 
             chains = 2, iter = 2000, 
             warmup = 1000)

```
Compare with WAIC.
```{r, echo=F}
load("fit_1.RData")
load("fit_2.Rdata")
load("fit_3.Rdata")
load("fit_4.Rdata")
```

```{r warning=F, message=F, eval=F}
incong_waic <- waic(fit_1, fit_2)
cong_waic <- waic(fit_3, fit_4)
```

Incongruent comparison:
```{r, echo=F}
load("incong_waic.Rdata")
load("cong_waic.Rdata")
```

```{r}
# difference
incong_waic$ic_diffs__

# SEs away from zero
abs(incong_waic$ic_diffs__[1]) / incong_waic$ic_diffs__[2]
```

Congruent comparison:
```{r}
# difference
cong_waic$ic_diffs__

# SEs away from zero
abs(cong_waic$ic_diffs__[1]) / cong_waic$ic_diffs__[2]
```

Make plot 1 from the fitted objects. First for the incongruent model. Figure 1 (bottom):
```{r message = F}
# use "Times" font
windowsFonts(Times = windowsFont("Times New Roman"))

re_mean_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("r_ID")) %>% 
  select(-contains("sigma"))

fe_mean_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("b_Intercept")) 

re_mean_in <- (re_mean_in + fe_mean_in[,1]) 
colnames(re_mean_in) <- 1:121

# empirical estimates
emp_est_in <- stroop %>% 
  filter(congruency == "incongruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1A <- melt(re_mean_in) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_mu = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(mu_emp = emp_est_in$mean_emp) %>%
  arrange(mu_mu) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "mean", 
         outcome = "Incongruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(posterior_summary(fit_1, "b_")[1,1],2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_mu), 
             size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = mu_emp), 
             size = 2, 
             color = "#D55E00",
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Mean") +
  xlab("Ascending Index") +
  ggtitle("Incongruent") +
  scale_y_continuous(breaks = c(0.6, 0.7, 0.77, 0.9, 1))

plot_1A
```


Plot 1B:
```{r warning = F, message = F}
# extract posterior estimates
re_sigma_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("r_ID__sigma")) 

fe_sigma_in <- fit_1 %>% 
  data.frame() %>% 
  select(contains("b_sigma_Intercept")) 

re_sigma_in <- exp(re_sigma_in + fe_sigma_in[,1]) 
colnames(re_sigma_in) <- 1:121

# randomly sample 60 eople
set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

# plot 1a
plot_1B <- melt(re_sigma_in) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_sigma = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(sd_emp = emp_est_in$sd_emp) %>%
  arrange(mu_sigma) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "SD", 
         outcome = "Incongruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(exp(posterior_summary(fit_1, "b_")[2,1]),2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_sigma), size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = sd_emp), 
             size = 2, 
             color = "#D55E00", 
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 16)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Standard Deviation") +
  xlab("Ascending Index") +
  ggtitle("")

plot_1B
```


The following has the empirical and model based estimates in the same plot. Plot 1C:
```{r }
dat_model_in <- data.frame(type = "Hierarchical",  
                           mean = colMeans(re_mean_in), 
                           sd = colMeans(re_sigma_in))


dat_data_in <- data.frame(type = "Empirical",  
                          mean = emp_est_in$mean_emp, 
                          sd = emp_est_in$sd_emp)


dat_plt_in <- rbind.data.frame(dat_model_in, dat_data_in)
dat_plt_in$ID <- 1:121

plot_1C <- ggplot(dat_plt_in, aes(y = sd, 
                                  x = mean, 
                                  color = type)) +
  geom_line(aes( group = ID), 
            color =  "black", 
            alpha = 0.25, 
            size = 1) +
  geom_point(size = 2, alpha = 0.75) +
  geom_smooth(method = "lm", se = F, show.legend = F) +
  scale_color_manual(values =c( "#0072B2", "#D55E00")) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14),
        legend.text = element_text(size = 13),
        legend.justification=c(1,0), 
        legend.position=c(1,0),
        legend.title = element_blank(), 
        legend.background = element_rect(color = "black"),
        legend.margin=margin(c(1,1,1,1))) +
  xlab("Mean") +
  ylab("Standard Deviation") +
  guides(colour = guide_legend(override.aes = list(alpha = 1))) +
  ggtitle("") 

plot_incong <- plot_grid(plot_1A, plot_1B, plot_1C, nrow = 1)

# ggsave(plot = plot_incong, filename = "plot_1.pdf", width = 8, height = 5)
```

Continue making plot 1 from the fitted objects. Now for the congruent model. Figure 1 (top):
```{r message=F}
re_mean_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("r_ID")) %>% 
  select(-contains("sigma"))

fe_mean_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("b_Intercept")) 

re_mean_con <- (re_mean_con + fe_mean_con[,1]) 
colnames(re_mean_con) <- 1:121

# empirical estimates
emp_est_con <- stroop %>% 
  filter(congruency == "congruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)


set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1D <- melt(re_mean_con) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_mu = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(mu_emp = emp_est_con$mean_emp) %>%
  arrange(mu_mu) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "mean", 
         outcome = "Congruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(posterior_summary(fit_3, "b_")[1,1],2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up), 
                width = 0.05) +
  
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_mu), 
             size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  
  # empirical estimates
  geom_point(aes(x = index, 
                 y = mu_emp), 
             size = 2, 
             color = "#D55E00",
             alpha = 0.75) +
  
  # times font
  theme_bw(base_family = "Times") +
  
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Mean") +
  xlab("Ascending Index") +
  ggtitle("Congruent") +
  scale_y_continuous(breaks = c(0.6, 0.71, 0.8, 0.9, 1))

plot_1D
```


```{r message=F}
re_sigma_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("r_ID__sigma")) 

fe_sigma_con <- fit_3 %>% 
  data.frame() %>% 
  select(contains("b_sigma_Intercept")) 

re_sigma_con <- exp(re_sigma_con + fe_sigma_con[,1]) 
colnames(re_sigma_con) <- 1:121

# empirical estimates
emp_est_con <- stroop %>% 
  filter(congruency == "congruent") %>% 
  group_by(ID) %>% 
  summarise(sd_emp = sd(rt), mean_emp = mean(rt))

set.seed(1)
random_draw <- sample(1:121, 60, replace = F)

plot_1E <- melt(re_sigma_con) %>% 
  group_by(variable) %>% 
  # compute mean and intervals
  summarise(mu_sigma = mean(value), 
            low = quantile(value, 0.05),
            up = quantile(value, 0.95)) %>% 
  # order small to large
  mutate(sd_emp = emp_est_con$sd_emp) %>%
  arrange(mu_sigma) %>%
  mutate(index = as.factor(1:121), 
         dist_param = "SD", 
         outcome = "Congruent") %>%
  filter(index %in% random_draw) %>%
  ggplot() +
  # fixed effect line
  geom_hline(yintercept = round(exp(posterior_summary(fit_3, "b_")[2,1]),2), 
             linetype = "twodash",
             alpha = 0.50) +
  # error bars
  geom_errorbar(aes(x = index, 
                    ymin = low, 
                    ymax = up),width = 0.05) +
  # model based estimates
  geom_point(aes(x = index, 
                 y = mu_sigma), size = 2, 
             color = "#0072B2", 
             alpha = 0.75) +
  # empirical estimates
  geom_point(aes(x = index, 
                 y = sd_emp), 
             size = 2, 
             color = "#D55E00", 
             alpha = 0.75) +
  # times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14)) +
  scale_x_discrete(expand = c(0.01, 0.01)) +
  ylab("Standard Deviation") +
  xlab("Ascending Index") +
  ggtitle("") +
  scale_y_continuous(breaks = c(0.1, 0.17, 0.3))

plot_1E
```


Model based and emprical plot:
```{r}
dat_model_con <- data.frame(type = "Hierarchical",  
                            mean = colMeans(re_mean_con), 
                            sd = colMeans(re_sigma_con))


dat_data_con <- data.frame(type = "Empirical",  
                           mean = emp_est_con$mean_emp, 
                           sd = emp_est_con$sd_emp)


dat_plt_con <- rbind.data.frame(dat_model_con, dat_data_con)
dat_plt_con$ID <- 1:121

plot_1F <- ggplot(dat_plt_con, aes(y = sd, 
                                   x = mean, 
                                   color = type)) +
  geom_line(aes( group = ID), 
            color =  "black", 
            alpha = 0.25, 
            size = 1) +
  # points
  geom_point(size = 2, 
             alpha = 0.75) +
  # add fitted line
  geom_smooth(method = "lm", 
              se = F, 
              show.legend = F) +
  # color blind pallette
  scale_color_manual(values =c( "#0072B2", "#D55E00"), 
                     name = "") +
  # fav theme with times font
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x =   element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 16),
        legend.position = "none") +
  xlab("Mean") +
  ylab("Standard Deviation") +
  # remove transparency from legend points
  guides(colour = guide_legend(override.aes = list(alpha=1))) +
  ggtitle("") 


plot_cong <- plot_grid(plot_1D, plot_1E, plot_1F, nrow = 1)
plot_1 <- plot_grid(plot_cong, plot_incong, nrow = 2)

plot_1
ggsave(filename = "plot_1.pdf", plot = plot_1, width = 9.5, height = 6.5)
```


We also breifly compared the correlation between the model based and emprical means and standard deviations. For the incongruent responses:
```{r}
# correlate incongruent M's and SD's

# emprical
emp_cor_in <- cor(dat_data_in[,2:3])[1,2]

# bootstrap (n = 121)
boot_in <- replicate(1000, cor(dat_data_in[sample(1:121, 121, replace = T),2:3])[1,2])

# boostrap SE
emp_cor_sd_in <- sd(boot_in)

# model mean
model_cor_in <- mean(posterior_samples(fit_1, pars = "cor")[,1])

# model SE (post SD)
model_cor_sd_in <- sd(posterior_samples(fit_1, pars = "cor")[,1])

# data frame
dat_in <- data.frame(type = c("emprical", "model"), 
           cor = c(emp_cor_in, model_cor_in),
           cor_sd = c(emp_cor_sd_in, model_cor_sd_in))
# results
dat_in
```

Now for the congruent responses:
```{r}
# correlate congruent M's and SD's

# empirical
emp_cor_con <- cor(dat_data_con[,2:3])[1,2]

# boostrap (n = 121)
boot_con <- replicate(1000, cor(dat_data_con[sample(1:121, 121, replace = T),2:3])[1,2])

# boostrap SE
emp_cor_sd_con <- sd(boot_con)

# model mean
model_cor_con <- mean(posterior_samples(fit_3, pars = "cor")[,1])

# model SE (post SD)
model_cor_sd_con <- sd(posterior_samples(fit_3, pars = "cor")[,1])

# data frame
dat_con <- data.frame(type = c("emprical", "model"), 
           cor = c(emp_cor_con, model_cor_con),
           cor_sd = c(emp_cor_sd_con, model_cor_sd_con))

# results
dat_con
```

Thus far the work showed how the mixed-effects location scale model can estimate mean-variance relations. This lead naturally to testing the correlations. The following visualizes the LKJ prior distribution for the partial correlations:
```{r}
n_samps <- 10000
prior_samples  <- lapply(1:4, function(x) rethinking::rlkjcorr(n_samps, K = 4, eta = x)[,,1][,2])

lkj_dat <- data.frame(nu = as.factor(rep(1:4, each = n_samps)), 
                      sample = unlist(prior_samples))

lkj_dat %>% 
  ggplot() +
  # for linetype
  geom_line(stat = "density", 
            aes(linetype = nu, x = sample), 
            adjust = 1.5) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.title = element_text(size = 14),
        # top right legend
        legend.justification=c(1,1), 
        legend.position=c(1,1),
        legend.background = element_rect(color = "black")) +
  xlab( expression("Marginal Prior Distribution"~ italic(rho[i][j]))) +
  ylab("Density") +
  scale_linetype_manual(name = expression("  "~italic(nu)), 
                        values = c("solid", "longdash", "dotted", "dotdash"))

```

We proceed to fit the full models:
```{r, eval=F}
form <- brmsformula(rt ~ congruency + (congruency |c| ID), 
                           sigma  ~ congruency + (congruency |c| ID))



priors <- c(
  # correlations
  set_prior("lkj(2)", class = "cor"),
  # location random SD
  set_prior("normal(0,0.25)", 
            class = "sd", 
            coef = "congruencyincongruent", 
            group = "ID"),
  # location random SD
  set_prior("normal(0,0.25)",
            class = "sd", 
            coef = "Intercept",
            group = "ID"),
  # scale random SD
  set_prior("normal(0,1)", 
            class = "sd",
            coef = "congruencyincongruent", 
            group = "ID", 
            dpar = "sigma"), 
  # scale random SD
  set_prior("normal(0,1)", 
            class = "sd", 
            coef = "Intercept", 
            group = "ID", 
            dpar = "sigma"), 
  # fixed effect priors
  set_prior("normal(0,5)", 
            class = "b"),
  set_prior("normal(0,5)", 
            class = "b", 
            dpar = "sigma"),
  set_prior("normal(0,5)", 
            class = "Intercept"),
  set_prior("normal(0,5)", 
            class = "Intercept", 
            dpar = "sigma"))

fit_stroop <- brm(form, data = stroop, 
                  inits = 0, cores = 4, 
                  chains = 4, iter = 3500, 
                  warmup = 1000, prior = priors)


fit_flank <- brm(form_stroop, data = flanker, 
                 inits = 0, cores = 4, 
                 chains = 4, iter = 3500, 
                 warmup = 1000,  
                 prior = priors)

save(fit_stroop, file = "fit_stroop.Rdata")
save(fit_flank, file = "fit_flank.Rdata")

```


Now the customary mixed-effects model (no scale model):

```{r, eval=F}
form_me <- brmsformula(rt ~ congruency + (congruency |c| ID))


# ME priors 
priors_me <- c(
  set_prior("lkj(2)", class = "cor"),
  # location random SD
  set_prior("normal(0,0.25)", 
            class = "sd", 
            coef = "Intercept", 
            group = "ID"),
  set_prior("normal(0,0.25)", 
            class = "sd",
            coef = "congruencyincongruent", 
            group = "ID"), 
                  # fixed effect priors
                  set_prior("normal(0,5)", 
                            class = "b"),
                  set_prior("normal(0,5)", 
                            class = "Intercept"))

fit_stroop_me <- brm(form_me, data = stroop, 
                  inits = 0, cores = 4, 
                  chains = 4, iter = 3500, 
                  warmup = 1000, prior = priors_me)


fit_flank_me <- brm(form_me, data = flanker, 
                    inits = 0, cores = 4, 
                    chains = 4, iter = 3500, 
                    warmup = 1000,  
                    prior = priors_me)


````

To address concerns of overfitting, we compared these models with WAIC. The Stroop task:

```{r echo=F} 
load("stroop_waic.Rdata")
load("flank_waic.Rdata")
```

```{r, warning=F, message=F}
# stroop task
stroop_waic$ic_diffs__

# SEs away from zero
abs(stroop_waic$ic_diffs__[1]) / stroop_waic$ic_diffs__[2]
```

The Flanker task:
```{r, warning=F, message=F}
# flanker task
flank_waic$ic_diffs__

# SEs away from zero
abs(flank_waic$ic_diffs__[1]) / flank_waic$ic_diffs__[2]
```

Note that this was done to show the MELSM is preferred over the customary mixed-effects model. In our experience, we have never come across an example in which the MELSM did not have (much) lower WAIC (or LOO). 

The following contructs Figure 3 (Panel A). Start with the Stroop task. The MELSM is plotted with:
```{r}
load("fit_stroop.Rdata")
load("fit_stroop_me.Rdata")
load("fit_flank.Rdata")
load("fit_flank_me.Rdata")
```

```{r}
# point estimates from linear regression
coefs_nonreg <- unlist(lapply(1:121, function(x) coefficients(lm(rt ~ congruency, data = subset(stroop, ID == x)))[2]))

# "Stroop effect"
melsm_stroop <- round(posterior_summary(fit_stroop, pars = "b_")[3,1], 3)



dat_stroop <- data.frame(y = coefs_nonreg, 
                         index= 1:121) %>% 
              arrange(y) %>%
              mutate(index2 = as.factor(1:121))

# melsm
melsm_stroop_plot <- coef(fit_stroop, probs = c(0.05, 0.95))$ID[,,2] %>% 
  data.frame() %>%
  arrange(Estimate) %>%
  mutate(sig = as.factor(ifelse(Q5 < melsm_stroop & Q95 > melsm_stroop, 0, 1)),
         index = as.factor(1:121),
         type = "MELSM") %>%
  ggplot() +
  facet_grid(~ type ) +
  geom_errorbar(aes(x = index, 
                    ymin = Q5, 
                    ymax = Q95, 
                    color = sig), 
                show.legend = F,
                width = 0) +
  geom_hline(yintercept = melsm_stroop,
             alpha = 0.50,
             linetype = "twodash") +
  geom_hline(yintercept = 0,
             alpha = 0.50,
             linetype = "dotted") +
  geom_point(aes(x = index, 
                 y = Estimate,
                 group = sig),
             size = 2, 
             alpha = 0.75) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14),
        strip.background = element_rect(fill = "grey94"),
        strip.text = element_text(size = 14)) +
  ylab(expression(atop(italic(beta[1])* " + " *italic(u[1][i])*"  (ms)", "Stroop Effect on RT"))) +
  scale_color_manual(values = c("#009E73", "#CC79A7")) +
  xlab("") +
  xlab("") + 
  geom_path(inherit.aes = F, 
            data = dat_stroop, 
            aes(x = as.numeric(index2), 
                y = y), 
            color = "grey",
            size = 1.5, alpha = 0.75) +
  scale_y_continuous(breaks = seq(-.1, .2, 0.05), 
                     labels = seq(-.1, .2, 0.05) * 1000) +
  scale_x_discrete(expand = c(0.015, 0.015)) +
  ggtitle("")

#melsm_stroop_plot
```


The ME (mixed-effect model) is plotted with:
```{r}
# Stroop effect
me_stroop <- round(posterior_summary(fit_stroop_me, pars = "b_")[2,1], 3)

# plot
me_stroop_plot <- coef(fit_stroop_me, probs = c(0.05, 0.95))$ID[,,2] %>% 
  data.frame() %>%
  arrange(Estimate) %>%
  mutate(sig = as.factor(ifelse(Q5 < me_stroop & Q95 > me_stroop, 0, 1)),
         index = as.factor(1:121),
         type = "MEM") %>%
  ggplot() +
  facet_grid(~ type ) +
  geom_errorbar(aes(x = index, 
                    ymin = Q5, 
                    ymax = Q95, 
                    color = sig), 
                show.legend = F,
                width = 0) +
  geom_hline(yintercept = me_stroop,
             alpha = 0.50,
             linetype = "twodash") +
  geom_hline(yintercept = 0,
             alpha = 0.50,
             linetype = "dotted") +
  geom_point(aes(x = index, 
                 y = Estimate,
                 group = sig),
             size = 2, 
             alpha = 0.75) +
  theme_bw(base_family = "Times") +
  # plot options
  theme(panel.grid.major.x = element_blank(), 
        panel.grid.minor.y = element_blank(),
        axis.text.x = element_blank(),
        axis.title = element_text(size = 14),
        title = element_text(size = 14),
        strip.background = element_rect(fill = "grey94"),
        strip.text = element_text(size = 14)) +
  ylab(expression(atop(italic(beta[1])* " + " *italic(u[1][i])*"  (ms)", "Stroop Effect on RT"))) +
  scale_color_manual(values = c("#009E73", "#CC79A7")) +
  xlab("") +
  xlab("") + 
  geom_path(inherit.aes = F, 
            data = dat_stroop, 
            aes(x = as.numeric(index2), 
                y = y), 
            color = "grey",
            size = 1.5, 
            alpha = 0.75) +

  scale_y_continuous(breaks = seq(-.1, .2, 0.05), 
                     labels = seq(-.1, .2, 0.05) * 1000) +
  ggtitle("Stroop") +
  scale_x_discrete(expand = c(0.015, 0.015)) 

#me_stroop_plot
```

Combine plots:
```{r}
plot_grid(me_stroop_plot, melsm_stroop_plot)
```
